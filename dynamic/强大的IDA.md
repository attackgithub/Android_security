# 强大的IDA
* F5快捷键可以将arm指令转化成可读的C语言，这里同时可以使用Y键，修改JNIEnv的函数方法名
* 还原JNI函数方法名（需要导入一个文件）
* Shirt+F12快捷键，速度打开so中所有的字符串内容窗口
* Ctrl+S快捷键，有两个用途，在正常打开so文件的IDA View视图的时候，可以查看so对应的Segement信息
* G快捷键：在IDA调试页面的时候，我们可以使用S键快速跳转到指定的内存位置
* 有时候我们发现跳转到指定位置之后，看到的全是DCB数据，这时候我们选择函数地址，点击P键就可以看到arm指令源码了
* 调试快捷键：F8单步调试，F7单步进入调试

# 常用的ARM指令集

1、arm指令中的寻址方式

1>. 立即数寻址
也叫立即寻址，是一种特殊的寻址方式，操作数本身包含在指令中，只要取出指令也就取到了操作数。这个操作数叫做立即数，对应的寻址方式叫做立即寻址。例如：
MOV R0,#64   ；R0  ← 64
2>. 寄存器寻址
寄存器寻址就是利用寄存器中的数值作为操作数，也称为寄存器直接寻址。
例如：ADD R0，R1， R2   ；R0  ← R1 + R2
3>. 寄存器间接寻址
寄存器间接寻址就是把寄存器中的值作为地址，再通过这个地址去取得操作数，操作数本身存放在存储器中。
例如：
LDR R0，[R1]	；R0 ←[R1]
4>. 寄存器偏移寻址
这是ARM指令集特有的寻址方式，它是在寄存器寻址得到操作数后再进行移位操作，得到最终的操作数。
例如：
MOV R0，R2，LSL  #3   ；R0 ← R2 * 8 ，R2的值左移3位，结果赋给R0。
5>. 寄存器基址变址寻址
寄存器基址变址寻址又称为基址变址寻址，它是在寄存器间接寻址的基础上扩展来的。它将寄存器（该寄存器一般称作基址寄存器）中的值与指令中给出的地址偏移量相加，从而得到一个地址，通过这个地址取得操作数。
例如：
LDR R0，[R1，#4]	；R0 ←[R1 + 4]，将R1的内容加上4形成操作数的地址，取得的操作数存入寄存器R0中。
6>. 多寄存器寻址
这种寻址方式可以一次完成多个寄存器值的传送。例如：
LDMIA  R0，{R1，R2，R3，R4}	；R1←[R0]，R2←[R0+4]，R3←[R0+8]，R4←[R0+12]
7>. 堆栈寻址
堆栈是一种数据结构，按先进后出（First In Last Out，FILO）的方式工作，使用堆栈指针（Stack Pointer, SP）指示当前的操作位置，堆栈指针总是指向栈顶。
堆栈寻址举例如下：
STMFD  SP！，｛R1－R7, LR｝	；将R1－R7, LR压入堆栈。满递减堆栈。
LDMED  SP！，｛R1－R7, LR｝	；将堆栈中的数据取回到R1－R7, LR寄存器。空递减堆栈。

2、ARM中的寄存器

R0-R3:用于函数参数及返回值的传递
R4-R6, R8, R10-R11:没有特殊规定，就是普通的通用寄存器
R7:栈帧指针(Frame Pointer).指向前一个保存的栈帧(stack frame)和链接寄存器(link register， lr)在栈上的地址。
R9:操作系统保留
R12:又叫IP(intra-procedure scratch )
R13:又叫SP(stack pointer)，是栈顶指针
R14:又叫LR(link register)，存放函数的返回地址。
R15:又叫PC(program counter)，指向当前指令地址。

3、ARM中的常用指令含义

ADD	加指令
SUB 	减指令
STR	把寄存器内容存到栈上去
LDR	把栈上内容载入一寄存器中
.W	是一个可选的指令宽度说明符。它不会影响为此指令的行为，它只是确保生成 32 位指令。Infocenter.arm.com的详细信息
BL	执行函数调用，并把使lr指向调用者(caller)的下一条指令，即函数的返回地址
BLX	同上，但是在ARM和thumb指令集间切换。
CMP	指令进行比较两个操作数的大小


